<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Fragments Visual Explorer</title>
  <style>
    body { font-family: system-ui, Helvetica, Arial, sans-serif; margin: 0; background: #0b0f14; color: #e6edf3; }
    header { padding: 12px 16px; border-bottom: 1px solid #1f2937; position: sticky; top: 0; background: #0b0f14; z-index: 2; }
    .controls { display: grid; grid-template-columns: 1.2fr 1fr 1fr 1fr 0.9fr 0.9fr 1fr 1.2fr 0.9fr 0.9fr; gap: 8px; align-items: center; }
    .controls input, .controls select, .controls button { padding: 8px; background: #0f1720; color: #e6edf3; border: 1px solid #233041; border-radius: 6px; }
    .controls button { cursor: pointer; }
    .wrap { display: grid; grid-template-columns: 320px 1fr; min-height: calc(100vh - 56px); }
    .sidebar { border-right: 1px solid #1f2937; padding: 12px; overflow: auto; }
    .sidebar h3 { margin: 12px 0 6px; font-size: 14px; color: #9fb3c8; }
    .facet { display: grid; gap: 6px; }
    .facet label { display: flex; justify-content: space-between; font-size: 13px; color: #bcd0e0; }
    .content { position: relative; }
    #viz { width: 100%; height: calc(100vh - 56px); }
    .tooltip { position: absolute; background: #0f1720; color: #e6edf3; border: 1px solid #233041; padding: 8px; border-radius: 6px; font-size: 12px; pointer-events: none; opacity: 0; }
    .legend { position: absolute; right: 8px; bottom: 8px; background: rgba(12,16,21,0.6); border:1px solid #233041; border-radius:8px; padding:8px; font-size:12px; }
    .legend div { margin: 2px 0; }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
</head>
<body>
  <header>
    <div class="controls">
      <input id="q" placeholder="Search fragments (title, content)…" />
      <select id="provider"><option value="">Provider: any</option></select>
      <select id="life_event"><option value="">Life event: any</option></select>
      <select id="category"><option value="">Category: any</option></select>
      <select id="mode">
        <option value="fragments">Mode: Fragment pairs</option>
        <option value="pages">Mode: Page overlap (from fragments)</option>
        <option value="pages2">Mode: Pages (tags/embedding)</option>
        <option value="links">Mode: Link graph</option>
        <option value="lifegraph">Mode: Life events graph</option>
      </select>
      <select id="metric">
        <option value="combined">Metric: combined</option>
        <option value="title">Metric: title</option>
        <option value="content">Metric: content</option>
        <option value="link">Metric: link</option>
      </select>
      <select id="page_metric" style="display:none">
        <option value="combined">Page metric: combined</option>
        <option value="tags">Page metric: tags</option>
        <option value="embedding">Page metric: embedding</option>
      </select>
      <label style="display:flex;gap:6px;align-items:center;color:#9fb3c8;font-size:12px">Min score <input id="thresh" type="range" min="0" max="1" step="0.01" value="0.6" style="width:120px"/><span id="thresh_val">0.60</span></label>
      <label style="display:flex;gap:6px;align-items:center;color:#9fb3c8;font-size:12px"><input id="ignore_generic" type="checkbox" checked/> Ignore generic titles</label>
      <input id="site_a" placeholder="Site A (default servicesaustralia.gov.au)" />
      <input id="site_b" placeholder="Site B (default my.gov.au)" />
      <button id="run">Update</button>
      <button id="rebuild_pages">Build pages index</button>
      <button id="export">Export overlaps (CSV)</button>
    </div>
  </header>
  <div class="wrap">
    <aside class="sidebar">
      <h3>Facets</h3>
      <div id="facet_life_events" class="facet"></div>
      <div id="facet_categories" class="facet"></div>
      <div id="facet_provider" class="facet"></div>
    </aside>
    <main class="content">
      <svg id="viz"></svg>
      <div class="tooltip" id="tooltip"></div>
      <div class="legend" id="legend"></div>
    </main>
  </div>
  <script>
    const API = (location.protocol.startsWith('http') ? location.origin : 'http://localhost:3000');
    const svg = d3.select('#viz');
    const tip = d3.select('#tooltip');
    const legend = d3.select('#legend');
    let width, height;

    function resize() {
      width = svg.node().clientWidth;
      height = svg.node().clientHeight;
      svg.attr('viewBox', `0 0 ${width} ${height}`);
    }
    window.addEventListener('resize', resize);
    resize();

    async function fetchFacets() {
      const res = await fetch(`${API}/api/fragments/facets`);
      const facets = await res.json();
      renderFacet('facet_life_events', facets.life_events || []);
      renderFacet('facet_categories', facets.categories || []);
      renderFacet('facet_provider', facets.provider || []);
      // Populate header selects
      const provSel = document.getElementById('provider');
      (facets.provider||[]).slice(0,100).forEach(f => {
        const o = document.createElement('option'); o.value = f.value; o.textContent = `Provider: ${f.value} (${f.count})`; provSel.appendChild(o);
      });
      const leSel = document.getElementById('life_event');
      (facets.life_events||[]).slice(0,100).forEach(f => {
        const o = document.createElement('option'); o.value = f.value; o.textContent = `Life: ${f.value} (${f.count})`; leSel.appendChild(o);
      });
      const catSel = document.getElementById('category');
      (facets.categories||[]).slice(0,100).forEach(f => {
        const o = document.createElement('option'); o.value = f.value; o.textContent = `Cat: ${f.value} (${f.count})`; catSel.appendChild(o);
      });
    }

    function renderFacet(id, items) {
      const c = document.getElementById(id);
      c.innerHTML = '';
      items.slice(0, 30).forEach(it => {
        const label = document.createElement('label');
        const cb = document.createElement('input'); cb.type = 'checkbox'; cb.value = it.value; cb.addEventListener('change', update);
        label.appendChild(cb); label.appendChild(document.createTextNode(` ${it.value}`));
        const span = document.createElement('span'); span.textContent = it.count; label.appendChild(span);
        c.appendChild(label);
      });
    }

    async function fetchFragments({ q='*', life_event='', category='', provider='', pages=3 }) {
      const per_page = 200;
      let page = 1; const docs = [];
      
      // Use relational search for life events, regular search for others
      const useRelational = life_event && life_event !== '';
      const endpoint = useRelational ? '/api/fragments/search-relational' : '/api/fragments/search';
      
      while (page <= pages) {
        const params = new URLSearchParams({ q, per_page, page, include_html: 'false' });
        if (life_event && useRelational) {
          params.set('life_event', life_event);
          params.set('include_related', 'true'); // Include related life events for richer results
        } else if (life_event) {
          params.set('life_event', life_event);
        }
        if (category) params.set('category', category);
        if (provider) params.set('provider', provider);
        
        try {
          const res = await fetch(`${API}${endpoint}?` + params.toString());
          const data = await res.json();
          (data.results||[]).forEach(h => docs.push(h.document));
          
          // Store relationship data for life graph mode
          if (useRelational && data.relationships) {
            docs.relationshipData = data.relationships;
            docs.relatedEvents = data.related_events || [];
          }
          
          if (!data.results || data.results.length < per_page) break;
          page++;
        } catch (error) {
          console.error('Error fetching fragments:', error);
          break;
        }
      }
      return docs;
    }

    function hostnameOf(doc) {
      if (Array.isArray(doc.site_hierarchy) && doc.site_hierarchy.length) return doc.site_hierarchy[0];
      try { return new URL(doc.url).hostname; } catch { return ''; }
    }

    function colorFor(host) {
      if (host.includes('servicesaustralia.gov.au')) return '#60a5fa';
      if (host.includes('my.gov.au')) return '#34d399';
      return '#f59e0b';
    }

    // Pan & zoom behaviour
    const zoomBehavior = d3.zoom()
      .scaleExtent([0.2, 8])
      .on('zoom', (event) => {
        const layer = svg.select('g.zoom-layer');
        if (!layer.empty()) layer.attr('transform', event.transform);
      });
    svg.call(zoomBehavior);

    function draw(nodes, links=[]) {
      svg.selectAll('*').remove();
      // Background to capture drag/pan
      svg.append('rect')
        .attr('class', 'pan-bg')
        .attr('width', width)
        .attr('height', height)
        .attr('fill', 'transparent');

      const layer = svg.append('g').attr('class', 'zoom-layer');
      const gLinks = layer.append('g').attr('stroke', '#334155').attr('stroke-opacity', 0.5);
      const gNodes = layer.append('g');

      const sim = d3.forceSimulation(nodes)
        .force('link', d3.forceLink(links).id(d=>d.id)
          .distance(d=> 120 - 80 * Math.min(1, Math.max(0, d.score||0)))
          .strength(d=> 0.05 + 0.35 * Math.min(1, Math.max(0, d.score||0)))
        )
        .force('charge', d3.forceManyBody().strength(-30))
        .force('center', d3.forceCenter(width/2, height/2))
        .force('collision', d3.forceCollide().radius(d => 8 + Math.min(22, Math.max(6, (d.content_len||80)/50))));

      const link = gLinks.selectAll('line').data(links).enter().append('line')
        .attr('stroke-width', d => 0.5 + 4 * Math.min(1, Math.max(0, d.score||0)))
        .attr('stroke', d => d3.interpolateTurbo(Math.min(1, Math.max(0, d.score||0))));
      const node = gNodes.selectAll('circle').data(nodes).enter().append('circle')
        .attr('r', d => 6 + Math.min(16, Math.max(4, (d.content_len||80)/50)))
        .attr('fill', d => colorFor(d.host))
        .attr('stroke', '#0b0f14').attr('stroke-width', 1)
        .call(drag(sim))
        .on('mousemove', (e,d) => showTip(e,d))
        .on('mouseout', hideTip)
        .on('click', (e,d) => window.open(d.url, '_blank'));

      const label = gNodes.selectAll('text').data(nodes).enter().append('text')
        .text(d => d.title.slice(0, 80))
        .attr('font-size', 10)
        .attr('fill', '#93a8bf')
        .attr('pointer-events', 'none');

      sim.on('tick', () => {
        node.attr('cx', d => (d.x = (d.x==null? 0 : d.x)))
            .attr('cy', d => (d.y = (d.y==null? 0 : d.y)));
        label.attr('x', d => (d.x||0) + 10).attr('y', d => (d.y||0) + 4);
        link.attr('x1', d=>d.source.x).attr('y1', d=>d.source.y).attr('x2', d=>d.target.x).attr('y2', d=>d.target.y);
      });

      // Fit graph into view after layout settles
      const fitToView = () => {
        if (!nodes.length) return;
        const xs = nodes.map(d => d.x||0);
        const ys = nodes.map(d => d.y||0);
        const minX = Math.min(...xs), maxX = Math.max(...xs);
        const minY = Math.min(...ys), maxY = Math.max(...ys);
        const dx = (maxX - minX) || 1;
        const dy = (maxY - minY) || 1;
        const margin = 40;
        const sx = (width - 2*margin) / dx;
        const sy = (height - 2*margin) / dy;
        const scale = Math.max(0.2, Math.min(8, Math.min(sx, sy)));
        const cx = (minX + maxX) / 2;
        const cy = (minY + maxY) / 2;
        const tx = width / 2 - scale * cx;
        const ty = height / 2 - scale * cy;
        const t = d3.zoomIdentity.translate(tx, ty).scale(scale);
        svg.transition().duration(450).call(zoomBehavior.transform, t);
      };

      sim.on('end', fitToView);
      // Fallback fit after a short delay in case end doesn't fire promptly
      setTimeout(fitToView, 800);

      legend.html('')
        .append('div').html('<span style="color:#60a5fa">●</span> Services Australia')
        .parentNode
      legend.append('div').html('<span style="color:#34d399">●</span> myGov');
      legend.append('div').html('<span style="color:#f59e0b">●</span> Other');
    }

    function drag(sim) {
      function started(event) { if (!event.active) sim.alphaTarget(0.3).restart(); event.subject.fx = event.subject.x; event.subject.fy = event.subject.y; }
      function dragged(event) { event.subject.fx = event.x; event.subject.fy = event.y; }
      function ended(event) { if (!event.active) sim.alphaTarget(0); event.subject.fx = null; event.subject.fy = null; }
      return d3.drag().on('start', started).on('drag', dragged).on('end', ended);
    }

    function showTip(e, d) {
      tip.style('opacity', 1)
         .style('left', (e.clientX + 10) + 'px')
         .style('top', (e.clientY + 10) + 'px')
         .html(`<b>${escapeHtml(d.title)}</b><br/>${escapeHtml(d.host)}<br/><small>${escapeHtml(d.url)}</small>`);
    }
    function hideTip() { tip.style('opacity', 0); }
    function escapeHtml(s) { return (s||'').replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[c])); }

    function filterByFacets(docs) {
      const le = checkedValues('facet_life_events');
      const cat = checkedValues('facet_categories');
      const prov = checkedValues('facet_provider');
      return docs.filter(d =>
        (le.length===0 || (d.life_events||[]).some(x => le.includes(x))) &&
        (cat.length===0 || (d.categories||[]).some(x => cat.includes(x))) &&
        (prov.length===0 || prov.includes(d.provider))
      );
    }
    function checkedValues(id) {
      return Array.from(document.querySelectorAll(`#${id} input[type=checkbox]:checked`)).map(cb => cb.value);
    }

    async function update() {
      const q = document.getElementById('q').value || '*';
      const provider = document.getElementById('provider').value;
      const life_event = document.getElementById('life_event').value;
      const category = document.getElementById('category').value;
      const site_a = (document.getElementById('site_a').value || 'servicesaustralia.gov.au').trim();
      const site_b = (document.getElementById('site_b').value || 'my.gov.au').trim();
      const mode = document.getElementById('mode').value;
      const metric = document.getElementById('metric').value;
      const page_metric = document.getElementById('page_metric').value;
      const threshold = parseFloat(document.getElementById('thresh').value || '0.6');
      const ignore_generic = document.getElementById('ignore_generic').checked;

      const all = await fetchFragments({ q, provider, life_event, category, pages: 4 });
      const docs = filterByFacets(all);

      if (mode === 'fragments') {
        const nodes = docs.map(d => ({ id: d.id, url: d.url, title: d.title || '(untitled)', host: hostnameOf(d), content_len: (d.content_text||'').length }));
        let links = [];
        try {
          const params = new URLSearchParams({ site_a, site_b, threshold: String(threshold), max_pairs: '400', metric, ignore_generic: String(ignore_generic) });
          const resp = await fetch(`${API}/api/overlap?` + params.toString());
          const data = await resp.json();
          const nodeById = new Map(nodes.map(n => [n.id, n]));
          links = (data.top_pairs||[])
            .map(p => ({ source: p.a.id, target: p.b.id, score: p.score }))
            .filter(l => nodeById.has(l.source) && nodeById.has(l.target));
        } catch {}
        draw(nodes, links);
      } else if (mode === 'pages') {
        // Page mode
        const params = new URLSearchParams({ site_a, site_b, threshold: String(threshold), max_pairs: '1200', aggregate: 'page', metric, ignore_generic: String(ignore_generic) });
        const resp = await fetch(`${API}/api/overlap?` + params.toString());
        const data = await resp.json();
        const pages = data.top_pages||[];
        const pageNodes = new Map();
        function add(url) {
          const host = (()=>{ try { return new URL(url).hostname; } catch { return ''; } })();
          if (!pageNodes.has(url)) pageNodes.set(url, { id: url, url, title: url, host, content_len: 100 });
        }
        const links = pages.map(p => { add(p.a_url); add(p.b_url); const score = Math.min(1, (p.coverage * 0.6 + p.avg_score * 0.4)); return { source: p.a_url, target: p.b_url, score, label: `${p.matched_fragments}/${Math.max(p.a_fragments,p.b_fragments)} matched` }; });
        draw(Array.from(pageNodes.values()), links);
      } else if (mode === 'pages2') {
        const params = new URLSearchParams({ site_a, site_b, threshold: String(threshold), max_pairs: '2000', metric: page_metric });
        const resp = await fetch(`${API}/api/pages/similarity?` + params.toString());
        const data = await resp.json();
        const pairs = data.pairs || [];
        const nodeMap = new Map();
        function add(url, title){
          const host = (()=>{ try { return new URL(url).hostname; } catch { return ''; } })();
          if (!nodeMap.has(url)) nodeMap.set(url, { id:url, url, title: title||url, host, content_len: 100 });
        }
        const links = pairs.map(p => { add(p.a.url, p.a.title); add(p.b.url, p.b.title); return { source: p.a.url, target: p.b.url, score: p.score }; });
        draw(Array.from(nodeMap.values()), links);
      } else if (mode === 'links') {
        const params = new URLSearchParams({ site_a, site_b, cross_only: 'false', max_edges: '2000', max_nodes: '1500' });
        const resp = await fetch(`${API}/api/pages/graph?` + params.toString());
        const data = await resp.json();
        const nodes = (data.nodes || []).map(n => ({ id:n.id, url:n.url, title:n.title, host:n.host, content_len: 100 }));
        const links = (data.edges || []).map(e => ({ source: e.source, target: e.target, score: e.score || 0.5 }));
        draw(nodes, links);
      } else if (mode === 'lifegraph') {
        // Life events graph mode - shows relationships between life events based on fragment content
        await drawLifeEventsGraph(docs, life_event);
      }
    }

    // New function to visualize life events graph with fragment data
    async function drawLifeEventsGraph(fragments, focusEvent) {
      // Load the life events graph if available
      const graphEvents = window.australianLifeEvents || [];
      
      // Get page-level life event data via API
      let pageLifeEvents = {};
      let relationshipData = fragments.relationshipData || {};
      let relatedEvents = fragments.relatedEvents || [];
      
      try {
        // Fetch pages to get life event associations
        const pageResponse = await fetch(`${API}/api/pages/search?life_event=${focusEvent || ''}&per_page=500`);
        if (pageResponse.ok) {
          const pageData = await pageResponse.json();
          pageData.results?.forEach(page => {
            (page.document.life_events || []).forEach(event => {
              pageLifeEvents[event] = (pageLifeEvents[event] || 0) + 1;
            });
          });
        }
      } catch (error) {
        console.error('Error fetching page life events:', error);
        // Fallback: count from fragments (though this won't be accurate with new architecture)
        fragments.forEach(frag => {
          if (frag._relationship_score) {
            // This fragment has relationship scoring, use it
            const events = relatedEvents.length > 0 ? relatedEvents : [focusEvent];
            events.forEach(event => {
              pageLifeEvents[event] = (pageLifeEvents[event] || 0) + 1;
            });
          }
        });
      }

      // Build nodes from graph data + page counts
      const nodes = [];
      const nodeMap = new Map();
      
      graphEvents.forEach(ge => {
        const pageCount = pageLifeEvents[ge.event_name] || 0;
        // Include nodes that have pages OR are the focus event OR are related to focus event
        if (pageCount > 0 || 
           (focusEvent && ge.event_name === focusEvent) ||
           relatedEvents.includes(ge.event_name)) {
          const node = {
            id: ge.id,
            title: ge.event_name,
            url: '#',
            host: ge.cluster,
            content_len: pageCount * 10, // Size based on page count
            graph_data: ge,
            fragment_count: pageCount, // Actually page count now
            page_count: pageCount,
            x: ge.position_x * 10, // Scale positions
            y: ge.position_y * 10,
            fx: focusEvent === ge.event_name ? width/2 : null, // Fix focus event in center
            fy: focusEvent === ge.event_name ? height/2 : null,
            is_focus: ge.event_name === focusEvent,
            is_related: relatedEvents.includes(ge.event_name)
          };
          nodes.push(node);
          nodeMap.set(ge.id, node);
          nodeMap.set(ge.event_name, node);
        }
      });

      // Build links from graph relationships + co-occurrence data
      const links = [];
      
      // Add structural relationships from graph
      graphEvents.forEach(ge => {
        const sourceNode = nodeMap.get(ge.id);
        if (!sourceNode) return;
        
        // Prerequisites
        (ge.prerequisites || []).forEach(prereq => {
          const targetNode = nodeMap.get(prereq);
          if (targetNode) {
            links.push({
              source: sourceNode.id,
              target: targetNode.id,
              score: 0.8,
              type: 'prerequisite',
              label: 'requires'
            });
          }
        });
        
        // Next states
        (ge.next_states || []).forEach(next => {
          const targetNode = nodeMap.get(next);
          if (targetNode) {
            links.push({
              source: sourceNode.id,
              target: targetNode.id,
              score: 0.6,
              type: 'next_state',
              label: 'leads to'
            });
          }
        });
        
        // Frequent concurrents
        (ge.frequent_concurrents || []).forEach(concurrent => {
          const targetNode = nodeMap.get(concurrent);
          if (targetNode) {
            links.push({
              source: sourceNode.id,
              target: targetNode.id,
              score: 0.4,
              type: 'concurrent',
              label: 'often with'
            });
          }
        });
      });

      // Add relationship-based links from API data
      if (relationshipData && focusEvent) {
        const focusNode = nodeMap.get(focusEvent);
        if (focusNode && relationshipData.prerequisites) {
          relationshipData.prerequisites.forEach(prereq => {
            const prereqNode = nodeMap.get(prereq);
            if (prereqNode) {
              links.push({
                source: prereqNode.id,
                target: focusNode.id,
                score: 0.8,
                type: 'prerequisite',
                label: 'required first'
              });
            }
          });
        }
        
        if (focusNode && relationshipData.next_states) {
          relationshipData.next_states.forEach(next => {
            const nextNode = nodeMap.get(next);
            if (nextNode) {
              links.push({
                source: focusNode.id,
                target: nextNode.id,
                score: 0.6,
                type: 'next_state',
                label: 'often leads to'
              });
            }
          });
        }
        
        if (focusNode && relationshipData.frequent_concurrents) {
          relationshipData.frequent_concurrents.forEach(concurrent => {
            const concurrentNode = nodeMap.get(concurrent);
            if (concurrentNode) {
              links.push({
                source: focusNode.id,
                target: concurrentNode.id,
                score: 0.4,
                type: 'concurrent',
                label: 'happens together'
              });
            }
          });
        }
      }

      // Custom draw for life events graph
      drawLifeGraph(nodes, links);
    }

    // Specialized drawing for life events graph
    function drawLifeGraph(nodes, links) {
      svg.selectAll('*').remove();
      svg.append('rect').attr('class', 'pan-bg').attr('width', width).attr('height', height).attr('fill', 'transparent');

      const layer = svg.append('g').attr('class', 'zoom-layer');
      const gLinks = layer.append('g');
      const gNodes = layer.append('g');

      // Color scale for clusters
      const clusterColors = d3.scaleOrdinal(d3.schemeSet3);
      
      // Link styles by type
      const linkStyles = {
        prerequisite: { color: '#ef4444', width: 2, dash: 'none' },
        next_state: { color: '#3b82f6', width: 1.5, dash: 'none' },
        concurrent: { color: '#10b981', width: 1, dash: '5,5' },
        co_occurrence: { color: '#6b7280', width: 0.5, dash: '2,2' }
      };

      const sim = d3.forceSimulation(nodes)
        .force('link', d3.forceLink(links).id(d => d.id).distance(d => 100).strength(d => d.score))
        .force('charge', d3.forceManyBody().strength(-100))
        .force('center', d3.forceCenter(width/2, height/2))
        .force('collision', d3.forceCollide().radius(d => 10 + Math.sqrt(d.fragment_count || 1) * 3));

      // Links with arrow markers
      svg.append('defs').selectAll('marker')
        .data(['prerequisite', 'next_state', 'concurrent', 'co_occurrence'])
        .enter().append('marker')
        .attr('id', d => `arrow-${d}`)
        .attr('viewBox', '0 -5 10 10')
        .attr('refX', 15)
        .attr('refY', 0)
        .attr('markerWidth', 6)
        .attr('markerHeight', 6)
        .attr('orient', 'auto')
        .append('path')
        .attr('d', 'M0,-5L10,0L0,5')
        .attr('fill', d => linkStyles[d].color);

      const link = gLinks.selectAll('line').data(links).enter().append('line')
        .attr('stroke', d => linkStyles[d.type].color)
        .attr('stroke-width', d => linkStyles[d.type].width)
        .attr('stroke-dasharray', d => linkStyles[d.type].dash)
        .attr('marker-end', d => `url(#arrow-${d.type})`)
        .attr('opacity', 0.6);

      const node = gNodes.selectAll('g').data(nodes).enter().append('g')
        .attr('class', 'node-group')
        .call(drag(sim));

      // Node circles sized by fragment count
      node.append('circle')
        .attr('r', d => 8 + Math.sqrt(d.fragment_count || 1) * 2)
        .attr('fill', d => d.graph_data ? clusterColors(d.graph_data.cluster) : '#888')
        .attr('stroke', '#0b0f14')
        .attr('stroke-width', 2);

      // Fragment count badge
      node.append('text')
        .attr('class', 'count-badge')
        .attr('text-anchor', 'middle')
        .attr('dy', '0.3em')
        .attr('font-size', 10)
        .attr('fill', 'white')
        .attr('font-weight', 'bold')
        .text(d => d.fragment_count || 0);

      // Labels
      node.append('text')
        .text(d => d.title)
        .attr('x', d => 12 + Math.sqrt(d.fragment_count || 1) * 2)
        .attr('y', 4)
        .attr('font-size', 11)
        .attr('fill', '#e6edf3');

      // Hover effects
      node.on('mouseover', function(e, d) {
        d3.select(this).select('circle').attr('stroke-width', 3);
        
        // Highlight connected links
        link.attr('opacity', l => 
          (l.source.id === d.id || l.target.id === d.id) ? 1 : 0.2
        );
        
        // Show detailed tooltip
        const graphData = d.graph_data || {};
        tip.style('opacity', 1)
           .style('left', (e.clientX + 10) + 'px')
           .style('top', (e.clientY + 10) + 'px')
           .html(`
             <b>${escapeHtml(d.title)}</b><br/>
             Cluster: ${escapeHtml(graphData.cluster || 'Unknown')}<br/>
             Pages: ${d.page_count || 0}<br/>
             Type: ${escapeHtml(graphData.event_type || 'Unknown')}<br/>
             Age range: ${graphData.typical_age_range ? graphData.typical_age_range.join('-') : 'Any'}<br/>
             Duration: ${graphData.typical_duration_days || '?'} days<br/>
             ${d.is_focus ? '<em>Focus event</em>' : ''}
             ${d.is_related ? '<em>Related event</em>' : ''}
           `);
      })
      .on('mouseout', function() {
        d3.select(this).select('circle').attr('stroke-width', 2);
        link.attr('opacity', 0.6);
        hideTip();
      })
      .on('click', function(e, d) {
        // Filter to fragments with this life event
        document.getElementById('life_event').value = d.title;
        document.getElementById('mode').value = 'fragments';
        update();
      });

      sim.on('tick', () => {
        node.attr('transform', d => `translate(${d.x},${d.y})`);
        link.attr('x1', d => d.source.x)
            .attr('y1', d => d.source.y)
            .attr('x2', d => d.target.x)
            .attr('y2', d => d.target.y);
      });

      // Update legend for life events graph
      legend.html('')
        .append('div').html('<b>Life Events Graph</b>');
      legend.append('div').html('<span style="color:#ef4444">→</span> Prerequisite');
      legend.append('div').html('<span style="color:#3b82f6">→</span> Next state');
      legend.append('div').html('<span style="color:#10b981">→</span> Concurrent');
      legend.append('div').html('<span style="color:#6b7280">→</span> Relational');
      legend.append('div').html('<br/>Size = page count');
      legend.append('div').html('Click event to filter fragments');
    }

    document.getElementById('run').addEventListener('click', update);
    document.getElementById('export').addEventListener('click', async () => {
      const site_a = (document.getElementById('site_a').value || 'servicesaustralia.gov.au').trim();
      const site_b = (document.getElementById('site_b').value || 'my.gov.au').trim();
      const mode = document.getElementById('mode').value;
      const metric = document.getElementById('metric').value;
      const page_metric = document.getElementById('page_metric').value;
      const threshold = document.getElementById('thresh').value || '0.55';
      const ignore_generic = document.getElementById('ignore_generic').checked;
      let url;
      if (mode === 'pages2') {
        const params = new URLSearchParams({ site_a, site_b, threshold, max_pairs: '50000', format: 'csv', metric: page_metric });
        url = `${API}/api/pages/similarity?` + params.toString();
      } else {
        const params = new URLSearchParams({ site_a, site_b, threshold, max_pairs: '2000', format: 'csv', metric, ignore_generic: String(ignore_generic) });
        if (mode === 'pages') params.set('aggregate', 'page');
        url = `${API}/api/overlap?` + params.toString();
      }
      const a = document.createElement('a'); a.href = url; a.download = 'overlap_export.csv'; a.click();
    });

    document.getElementById('mode').addEventListener('change', (e) => {
      const showPageMetric = e.target.value === 'pages2';
      document.getElementById('page_metric').style.display = showPageMetric ? '' : 'none';
      update();
    });
    document.getElementById('page_metric').addEventListener('change', update);
    document.getElementById('metric').addEventListener('change', update);
    document.getElementById('thresh').addEventListener('input', (e)=>{ document.getElementById('thresh_val').textContent = (+e.target.value).toFixed(2); });
    document.getElementById('thresh').addEventListener('change', update);
    document.getElementById('ignore_generic').addEventListener('change', update);

    document.getElementById('rebuild_pages').addEventListener('click', async () => {
      const site_a = (document.getElementById('site_a').value || '').trim();
      const site_b = (document.getElementById('site_b').value || '').trim();
      const params = new URLSearchParams({ prune: 'true' });
      if (site_a) params.set('site_a', site_a);
      if (site_b) params.set('site_b', site_b);
      try {
        const resp = await fetch(`${API}/api/pages/rebuild?` + params.toString(), { method: 'POST' });
        const data = await resp.json();
        alert(`Pages indexed: ${data.pages_indexed} (from ${data.fragments_processed} fragments)`);
        update();
      } catch (e) {
        alert('Failed to rebuild pages: ' + e.message);
      }
    });

    fetchFacets().then(update);
  </script>
</body>
</html>
