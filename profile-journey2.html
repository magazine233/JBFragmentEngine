<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>myGov - Profile & Journey</title>
    
    <!-- Material-UI -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700&display=swap" />
    <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons" />
    
    <!-- React & Dependencies -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/@mui/material@5.14.0/umd/material-ui.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Three.js for 3D visualization -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <style>
        body {
            margin: 0;
            font-family: 'Roboto', sans-serif;
            background-color: #f5f5f5;
        }
        
        /* Profile Character Sheet Styles */
        .character-sheet {
            background: linear-gradient(135deg, #f5f5f5 0%, #e0e0e0 100%);
            border-radius: 16px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }
        
        .character-avatar {
            width: 120px;
            height: 120px;
            background: #66d3ee;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto 16px;
            box-shadow: 0 4px 16px rgba(102, 211, 238, 0.3);
            position: relative;
            cursor: pointer;
            transition: transform 0.3s ease;
        }
        
        .character-avatar:hover {
            transform: scale(1.05);
        }
        
        .character-avatar .meeple {
            font-size: 64px;
            color: #1976d2;
        }
        
        .level-badge {
            position: absolute;
            bottom: -5px;
            right: -5px;
            background: #ffd700;
            color: #333;
            border-radius: 50%;
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }
        
        /* Profile Stats */
        .profile-stat {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 8px;
            margin-bottom: 8px;
            transition: all 0.2s ease;
        }
        
        .profile-stat:hover {
            background: rgba(255, 255, 255, 1);
            transform: translateX(4px);
        }
        
        .stat-icon {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #e3f2fd;
            color: #1976d2;
        }
        
        /* Life Event Journey Cards */
        .journey-card {
            background: white;
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            overflow: hidden;
        }
        
        .journey-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.15);
        }
        
        .journey-progress {
            position: absolute;
            top: 0;
            left: 0;
            height: 4px;
            background: linear-gradient(90deg, #4caf50 0%, #8bc34a 100%);
            transition: width 0.3s ease;
        }
        
        .journey-icon {
            width: 48px;
            height: 48px;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 28px;
        }
        
        /* 3D Journey Map Container */
        #journey-map {
            width: 100%;
            height: 600px;
            border-radius: 16px;
            overflow: hidden;
            position: relative;
            background: linear-gradient(180deg, #87ceeb 0%, #98d8e8 50%, #b0e0e6 100%);
        }
        
        .map-controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 8px;
            background: rgba(255, 255, 255, 0.9);
            padding: 8px;
            border-radius: 24px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }
        
        /* Life Event Node Tooltip */
        .event-tooltip {
            position: absolute;
            background: white;
            padding: 16px;
            border-radius: 12px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
            max-width: 300px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s ease;
            z-index: 1000;
        }
        
        .event-tooltip.visible {
            opacity: 1;
        }
        
        /* Service Matcher Results */
        .service-match-card {
            background: white;
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 12px;
            border-left: 4px solid transparent;
            transition: all 0.2s ease;
        }
        
        .service-match-card.full-match {
            border-left-color: #4caf50;
        }
        
        .service-match-card.partial-match {
            border-left-color: #ff9800;
        }
        
        .service-match-card.potential-match {
            border-left-color: #9e9e9e;
        }
        
        .match-indicator {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            font-size: 0.875rem;
            padding: 4px 8px;
            border-radius: 16px;
            background: #f5f5f5;
        }
        
        .eligibility-gap {
            background: #fff3cd;
            color: #856404;
            padding: 8px 12px;
            border-radius: 8px;
            margin-top: 8px;
            font-size: 0.875rem;
        }
        
        /* Animations */
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        .pulse {
            animation: pulse 2s infinite;
        }
        
        @keyframes float {
            0% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
            100% { transform: translateY(0px); }
        }
        
        .float {
            animation: float 3s ease-in-out infinite;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const {
            AppBar, Toolbar, Typography, Container, Box, Card, CardContent, CardActions,
            Button, IconButton, TextField, Chip, Paper, Grid, List, ListItem,
            ListItemText, ListItemIcon, Checkbox, Accordion, AccordionSummary,
            AccordionDetails, Badge, LinearProgress, ToggleButton, ToggleButtonGroup,
            Tabs, Tab, Dialog, DialogTitle, DialogContent, DialogActions,
            Menu, MenuItem, Snackbar, Alert, Divider, InputAdornment,
            Radio, RadioGroup, FormControlLabel, FormControl, FormLabel,
            Avatar, Stack, Fade, Grow, Collapse, CircularProgress, Link,
            Slider, Switch, Select, Tooltip, SpeedDial, SpeedDialAction,
            Drawer, ListItemButton, Stepper, Step, StepLabel, StepContent
        } = MaterialUI;

        const { useState, useEffect, useRef, useCallback } = React;

        // API Configuration
        const API_BASE_URL = "http://localhost:3000";
        const API_ENDPOINTS = {
            search: `${API_BASE_URL}/api/fragments/search`,
            facets: `${API_BASE_URL}/api/fragments/facets`,
            profileBuild: `${API_BASE_URL}/api/journey/profile/build`,
            journey: `${API_BASE_URL}/api/journey`,
            visualization: `${API_BASE_URL}/api/journey/visualization`
        };
        
        // Life Event Icons
        const lifeEventIcons = {
            'Having a baby': 'üë∂',
            'Growing up': 'üéí',
            'Child health': 'üè•',
            'Relationship changes': 'üíë',
            'Domestic violence': 'üõ°Ô∏è',
            'Work': 'üíº',
            'Ageing': 'üë¥',
            'Education': 'üéì',
            'Health and caring': '‚ù§Ô∏è',
            'Family and relationships': 'üë®‚Äçüë©‚Äçüëß‚Äçüë¶',
            'Work and money': 'üí∞',
            'Housing and travel': 'üè†',
            'Disasters and crime': '‚ö†Ô∏è',
            'Education and identity': 'üé≠'
        };

        // Main App Component
        function App() {
            const [mode, setMode] = useState('profile');
            const [profile, setProfile] = useState(loadProfile());
            const [journeyMapOpen, setJourneyMapOpen] = useState(false);
            const [serviceMatcherOpen, setServiceMatcherOpen] = useState(false);
            const [selectedLifeEvent, setSelectedLifeEvent] = useState(null);
            const [matchedServices, setMatchedServices] = useState([]);
            const [activeJourneys, setActiveJourneys] = useState(loadActiveJourneys());
            
            const mapRef = useRef(null);
            const sceneRef = useRef(null);
            const rendererRef = useRef(null);
            const cameraRef = useRef(null);

            // Load profile from localStorage
            function loadProfile() {
                const stored = localStorage.getItem('userProfile');
                if (stored) return JSON.parse(stored);
                
                return {
                    id: 'user_' + Date.now(),
                    name: 'Guest User',
                    age: null,
                    income: null,
                    citizenship: ['Australian'],
                    residency_state: 'National',
                    employment_status: null,
                    housing_status: null,
                    has_children: false,
                    children: [],
                    is_carer: false,
                    has_disability: false,
                    current_life_events: [],
                    completed_life_events: [],
                    level: 1,
                    experience_points: 0
                };
            }

            // Load active journeys from localStorage
            function loadActiveJourneys() {
                const stored = localStorage.getItem('activeJourneys');
                if (stored) return JSON.parse(stored);
                return [];
            }

            // Save profile
            function saveProfile(newProfile) {
                setProfile(newProfile);
                localStorage.setItem('userProfile', JSON.stringify(newProfile));
            }

            // Calculate profile level based on completed events
            function calculateLevel(profile) {
                const xp = profile.completed_life_events.length * 100 + 
                          profile.current_life_events.length * 50;
                return Math.floor(xp / 500) + 1;
            }

            // Profile Character Sheet Component
            function ProfileSheet() {
                const [editMode, setEditMode] = useState(false);
                const [tempProfile, setTempProfile] = useState(profile);

                const handleSave = () => {
                    saveProfile(tempProfile);
                    setEditMode(false);
                };

                return (
                    <Card className="character-sheet">
                        <CardContent>
                            <Grid container spacing={3}>
                                {/* Character Avatar */}
                                <Grid item xs={12} sx={{ textAlign: 'center' }}>
                                    <Box className="character-avatar">
                                        <span className="meeple material-icons">person</span>
                                        <Box className="level-badge">{calculateLevel(profile)}</Box>
                                    </Box>
                                    <Typography variant="h5" gutterBottom>
                                        {profile.name}
                                    </Typography>
                                    <LinearProgress 
                                        variant="determinate" 
                                        value={(profile.experience_points % 500) / 5}
                                        sx={{ maxWidth: 200, mx: 'auto', mb: 2 }}
                                    />
                                </Grid>

                                {/* Profile Stats */}
                                <Grid item xs={12} md={6}>
                                    <Typography variant="h6" gutterBottom>
                                        Profile Details
                                    </Typography>
                                    
                                    <Box className="profile-stat">
                                        <Box className="stat-icon">
                                            <span className="material-icons">cake</span>
                                        </Box>
                                        <Box flex={1}>
                                            <Typography variant="body2" color="text.secondary">Age</Typography>
                                            {editMode ? (
                                                <TextField
                                                    size="small"
                                                    type="number"
                                                    value={tempProfile.age || ''}
                                                    onChange={(e) => setTempProfile({...tempProfile, age: parseInt(e.target.value)})}
                                                />
                                            ) : (
                                                <Typography>{profile.age || 'Not set'}</Typography>
                                            )}
                                        </Box>
                                    </Box>

                                    <Box className="profile-stat">
                                        <Box className="stat-icon">
                                            <span className="material-icons">attach_money</span>
                                        </Box>
                                        <Box flex={1}>
                                            <Typography variant="body2" color="text.secondary">Annual Income</Typography>
                                            {editMode ? (
                                                <TextField
                                                    size="small"
                                                    type="number"
                                                    value={tempProfile.income || ''}
                                                    onChange={(e) => setTempProfile({...tempProfile, income: parseInt(e.target.value)})}
                                                    InputProps={{
                                                        startAdornment: <InputAdornment position="start">$</InputAdornment>
                                                    }}
                                                />
                                            ) : (
                                                <Typography>${profile.income?.toLocaleString() || 'Not set'}</Typography>
                                            )}
                                        </Box>
                                    </Box>

                                    <Box className="profile-stat">
                                        <Box className="stat-icon">
                                            <span className="material-icons">work</span>
                                        </Box>
                                        <Box flex={1}>
                                            <Typography variant="body2" color="text.secondary">Employment</Typography>
                                            {editMode ? (
                                                <Select
                                                    size="small"
                                                    value={tempProfile.employment_status || ''}
                                                    onChange={(e) => setTempProfile({...tempProfile, employment_status: e.target.value})}
                                                    fullWidth
                                                >
                                                    <MenuItem value="">Not set</MenuItem>
                                                    <MenuItem value="employed">Employed</MenuItem>
                                                    <MenuItem value="unemployed">Unemployed</MenuItem>
                                                    <MenuItem value="student">Student</MenuItem>
                                                    <MenuItem value="retired">Retired</MenuItem>
                                                    <MenuItem value="self-employed">Self-employed</MenuItem>
                                                </Select>
                                            ) : (
                                                <Typography>{profile.employment_status || 'Not set'}</Typography>
                                            )}
                                        </Box>
                                    </Box>

                                    <Box className="profile-stat">
                                        <Box className="stat-icon">
                                            <span className="material-icons">home</span>
                                        </Box>
                                        <Box flex={1}>
                                            <Typography variant="body2" color="text.secondary">Housing</Typography>
                                            {editMode ? (
                                                <Select
                                                    size="small"
                                                    value={tempProfile.housing_status || ''}
                                                    onChange={(e) => setTempProfile({...tempProfile, housing_status: e.target.value})}
                                                    fullWidth
                                                >
                                                    <MenuItem value="">Not set</MenuItem>
                                                    <MenuItem value="owner">Home Owner</MenuItem>
                                                    <MenuItem value="renting">Renting</MenuItem>
                                                    <MenuItem value="public_housing">Public Housing</MenuItem>
                                                    <MenuItem value="homeless">Experiencing Homelessness</MenuItem>
                                                </Select>
                                            ) : (
                                                <Typography>{profile.housing_status || 'Not set'}</Typography>
                                            )}
                                        </Box>
                                    </Box>

                                    <Box className="profile-stat">
                                        <Box className="stat-icon">
                                            <span className="material-icons">child_care</span>
                                        </Box>
                                        <Box flex={1}>
                                            <FormControlLabel
                                                control={
                                                    <Switch
                                                        checked={profile.has_children}
                                                        onChange={(e) => setTempProfile({...tempProfile, has_children: e.target.checked})}
                                                        disabled={!editMode}
                                                    />
                                                }
                                                label="Has Children"
                                            />
                                        </Box>
                                    </Box>

                                    <Box className="profile-stat">
                                        <Box className="stat-icon">
                                            <span className="material-icons">favorite</span>
                                        </Box>
                                        <Box flex={1}>
                                            <FormControlLabel
                                                control={
                                                    <Switch
                                                        checked={profile.is_carer}
                                                        onChange={(e) => setTempProfile({...tempProfile, is_carer: e.target.checked})}
                                                        disabled={!editMode}
                                                    />
                                                }
                                                label="Is a Carer"
                                            />
                                        </Box>
                                    </Box>
                                </Grid>

                                {/* Active Journeys */}
                                <Grid item xs={12} md={6}>
                                    <Typography variant="h6" gutterBottom>
                                        Active Life Event Journeys
                                    </Typography>
                                    
                                    {activeJourneys.map((journey, index) => (
                                        <Box key={index} className="journey-card">
                                            <Box className="journey-progress" style={{ width: `${journey.progress}%` }} />
                                            <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
                                                <Box className="journey-icon" sx={{ background: journey.color }}>
                                                    {lifeEventIcons[journey.name] || 'üéØ'}
                                                </Box>
                                                <Box flex={1}>
                                                    <Typography variant="subtitle1">{journey.name}</Typography>
                                                    <Typography variant="body2" color="text.secondary">
                                                        {journey.completedTasks}/{journey.totalTasks} tasks completed
                                                    </Typography>
                                                </Box>
                                                <CircularProgress
                                                    variant="determinate"
                                                    value={journey.progress}
                                                    size={40}
                                                    thickness={4}
                                                />
                                            </Box>
                                        </Box>
                                    ))}

                                    {activeJourneys.length === 0 && (
                                        <Paper sx={{ p: 3, textAlign: 'center', bgcolor: 'grey.50' }}>
                                            <Typography color="text.secondary">
                                                No active journeys yet. Click "Something's Changed" to start your journey!
                                            </Typography>
                                        </Paper>
                                    )}
                                </Grid>
                            </Grid>
                        </CardContent>
                        <CardActions sx={{ justifyContent: 'space-between', p: 2 }}>
                            <Box>
                                {editMode ? (
                                    <>
                                        <Button onClick={handleSave} variant="contained" sx={{ mr: 1 }}>
                                            Save Profile
                                        </Button>
                                        <Button onClick={() => {
                                            setTempProfile(profile);
                                            setEditMode(false);
                                        }}>
                                            Cancel
                                        </Button>
                                    </>
                                ) : (
                                    <Button 
                                        onClick={() => setEditMode(true)}
                                        startIcon={<span className="material-icons">edit</span>}
                                    >
                                        Edit Profile
                                    </Button>
                                )}
                            </Box>
                            <Box>
                                <Button
                                    variant="contained"
                                    color="primary"
                                    onClick={() => setJourneyMapOpen(true)}
                                    startIcon={<span className="material-icons">explore</span>}
                                    sx={{ mr: 1 }}
                                >
                                    Something's Changed
                                </Button>
                                <Button
                                    variant="outlined"
                                    onClick={() => setServiceMatcherOpen(true)}
                                    startIcon={<span className="material-icons">search</span>}
                                >
                                    Find Services
                                </Button>
                            </Box>
                        </CardActions>
                    </Card>
                );
            }

            // Journey Map Visualization Component
            function JourneyMap() {
                const [hoveredEvent, setHoveredEvent] = useState(null);
                
                useEffect(() => {
                    if (!journeyMapOpen || !mapRef.current) return;

                    // Clear any existing content
                    while (mapRef.current.firstChild) {
                        mapRef.current.removeChild(mapRef.current.firstChild);
                    }

                    // Initialize Three.js scene
                    const scene = new THREE.Scene();
                    scene.background = new THREE.Color(0x87ceeb);
                    scene.fog = new THREE.Fog(0x87ceeb, 10, 100);

                    const camera = new THREE.PerspectiveCamera(
                        75,
                        mapRef.current.clientWidth / mapRef.current.clientHeight,
                        0.1,
                        1000
                    );
                    camera.position.set(0, 10, 20);
                    camera.lookAt(0, 0, 0);

                    const renderer = new THREE.WebGLRenderer({ antialias: true });
                    renderer.setSize(mapRef.current.clientWidth, mapRef.current.clientHeight);
                    renderer.shadowMap.enabled = true;
                    mapRef.current.appendChild(renderer.domElement);

                    // Add lighting
                    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                    scene.add(ambientLight);
                    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.4);
                    directionalLight.position.set(10, 20, 10);
                    directionalLight.castShadow = true;
                    scene.add(directionalLight);

                    // Create terrain
                    const terrainGeometry = new THREE.PlaneGeometry(100, 100, 50, 50);
                    const terrainMaterial = new THREE.MeshLambertMaterial({ 
                        color: 0x90ee90,
                        wireframe: false 
                    });
                    
                    // Add some height variation
                    const vertices = terrainGeometry.attributes.position.array;
                    for (let i = 0; i < vertices.length; i += 3) {
                        vertices[i + 2] = Math.sin(vertices[i] * 0.1) * Math.cos(vertices[i + 1] * 0.1) * 2;
                    }
                    terrainGeometry.computeVertexNormals();
                    
                    const terrain = new THREE.Mesh(terrainGeometry, terrainMaterial);
                    terrain.rotation.x = -Math.PI / 2;
                    terrain.receiveShadow = true;
                    scene.add(terrain);

                    // Create player avatar (meeple) using basic geometries
                    const meepleGroup = new THREE.Group();
                    
                    // Body (cone)
                    const bodyGeometry = new THREE.ConeGeometry(0.5, 2, 8);
                    const bodyMaterial = new THREE.MeshPhongMaterial({ color: 0x1976d2 });
                    const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                    body.position.y = 1;
                    body.castShadow = true;
                    meepleGroup.add(body);
                    
                    // Head (sphere)
                    const headGeometry = new THREE.SphereGeometry(0.5, 16, 16);
                    const head = new THREE.Mesh(headGeometry, bodyMaterial);
                    head.position.y = 2.5;
                    head.castShadow = true;
                    meepleGroup.add(head);
                    
                    meepleGroup.position.set(0, 0, 0);
                    scene.add(meepleGroup);

                    // Create life event nodes
                    const nodePositions = [
                        { x: 5, z: 0, event: 'Work', color: 0x3b82f6 },
                        { x: -5, z: 0, event: 'Having a baby', color: 0xec4899 },
                        { x: 0, z: 5, event: 'Education', color: 0xa78bfa },
                        { x: 0, z: -5, event: 'Health and caring', color: 0xef4444 },
                        { x: 7, z: 7, event: 'Housing and travel', color: 0xfbbf24 },
                        { x: -7, z: -7, event: 'Ageing', color: 0x8b5cf6 }
                    ];

                    const nodes = [];
                    nodePositions.forEach(pos => {
                        // Node base
                        const nodeGeometry = new THREE.CylinderGeometry(1, 1, 0.5, 16);
                        const nodeMaterial = new THREE.MeshPhongMaterial({ 
                            color: pos.color,
                            emissive: pos.color,
                            emissiveIntensity: 0.2
                        });
                        const node = new THREE.Mesh(nodeGeometry, nodeMaterial);
                        node.position.set(pos.x, 0.25, pos.z);
                        node.castShadow = true;
                        node.userData = { event: pos.event };
                        nodes.push(node);
                        scene.add(node);

                        // Add text sprite for label
                        const canvas = document.createElement('canvas');
                        canvas.width = 256;
                        canvas.height = 128;
                        const context = canvas.getContext('2d');
                        context.fillStyle = 'white';
                        context.fillRect(0, 0, 256, 128);
                        context.fillStyle = 'black';
                        context.font = '24px Arial';
                        context.textAlign = 'center';
                        context.fillText(pos.event, 128, 64);
                        
                        const texture = new THREE.CanvasTexture(canvas);
                        const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
                        const sprite = new THREE.Sprite(spriteMaterial);
                        sprite.position.set(pos.x, 3, pos.z);
                        sprite.scale.set(4, 2, 1);
                        scene.add(sprite);
                    });

                    // Create paths between nodes
                    const createPath = (start, end) => {
                        const points = [];
                        const steps = 20;
                        for (let i = 0; i <= steps; i++) {
                            const t = i / steps;
                            const x = start.x + (end.x - start.x) * t;
                            const z = start.z + (end.z - start.z) * t;
                            const y = 0.1 + Math.sin(t * Math.PI) * 0.5;
                            points.push(new THREE.Vector3(x, y, z));
                        }
                        
                        const pathGeometry = new THREE.BufferGeometry().setFromPoints(points);
                        const pathMaterial = new THREE.LineBasicMaterial({ 
                            color: 0xffffff,
                            linewidth: 3
                        });
                        return new THREE.Line(pathGeometry, pathMaterial);
                    };

                    // Add paths from current position to available nodes
                    const currentPos = { x: 0, z: 0 };
                    nodePositions.slice(0, 3).forEach(nodePos => {
                        const path = createPath(currentPos, nodePos);
                        scene.add(path);
                    });

                    // Camera controls
                    let cameraAngle = 0;
                    const cameraRadius = 30;
                    
                    // Animation loop
                    const animate = () => {
                        requestAnimationFrame(animate);

                        // Rotate meeple
                        meepleGroup.rotation.y += 0.01;

                        // Float nodes
                        nodes.forEach((node, i) => {
                            node.position.y = 0.25 + Math.sin(Date.now() * 0.001 + i) * 0.1;
                        });

                        // Auto-rotate camera slightly
                        cameraAngle += 0.002;
                        camera.position.x = Math.sin(cameraAngle) * cameraRadius;
                        camera.position.z = Math.cos(cameraAngle) * cameraRadius;
                        camera.lookAt(0, 0, 0);

                        renderer.render(scene, camera);
                    };

                    animate();

                    // Mouse interaction
                    const raycaster = new THREE.Raycaster();
                    const mouse = new THREE.Vector2();

                    const handleMouseMove = (event) => {
                        const rect = mapRef.current.getBoundingClientRect();
                        mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                        mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

                        raycaster.setFromCamera(mouse, camera);
                        const intersects = raycaster.intersectObjects(nodes);

                        if (intersects.length > 0) {
                            const node = intersects[0].object;
                            setHoveredEvent(node.userData.event);
                            setSelectedLifeEvent(node.userData.event);
                            document.body.style.cursor = 'pointer';
                        } else {
                            setHoveredEvent(null);
                            setSelectedLifeEvent(null);
                            document.body.style.cursor = 'default';
                        }
                    };

                    const handleResize = () => {
                        camera.aspect = mapRef.current.clientWidth / mapRef.current.clientHeight;
                        camera.updateProjectionMatrix();
                        renderer.setSize(mapRef.current.clientWidth, mapRef.current.clientHeight);
                    };

                    mapRef.current.addEventListener('mousemove', handleMouseMove);
                    window.addEventListener('resize', handleResize);

                    // Store refs for cleanup
                    sceneRef.current = scene;
                    rendererRef.current = renderer;
                    cameraRef.current = camera;

                    return () => {
                        if (mapRef.current) {
                            mapRef.current.removeEventListener('mousemove', handleMouseMove);
                        }
                        window.removeEventListener('resize', handleResize);
                        if (rendererRef.current) {
                            rendererRef.current.dispose();
                        }
                    };
                }, [journeyMapOpen]);

                return (
                    <Dialog
                        open={journeyMapOpen}
                        onClose={() => setJourneyMapOpen(false)}
                        maxWidth="lg"
                        fullWidth
                        PaperProps={{
                            sx: { height: '90vh' }
                        }}
                    >
                        <DialogTitle>
                            <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
                                <Typography variant="h5">Your Life Journey Map</Typography>
                                <IconButton onClick={() => setJourneyMapOpen(false)}>
                                    <span className="material-icons">close</span>
                                </IconButton>
                            </Box>
                        </DialogTitle>
                        <DialogContent sx={{ p: 0 }}>
                            <Box id="journey-map" ref={mapRef} />
                            
                            {/* Map Controls */}
                            <Box className="map-controls">
                                <IconButton size="small">
                                    <span className="material-icons">zoom_in</span>
                                </IconButton>
                                <IconButton size="small">
                                    <span className="material-icons">zoom_out</span>
                                </IconButton>
                                <IconButton size="small">
                                    <span className="material-icons">my_location</span>
                                </IconButton>
                                <IconButton size="small">
                                    <span className="material-icons">layers</span>
                                </IconButton>
                            </Box>

                            {/* Life Event Details */}
                            {selectedLifeEvent && (
                                <Paper
                                    sx={{
                                        position: 'absolute',
                                        bottom: 80,
                                        left: '50%',
                                        transform: 'translateX(-50%)',
                                        p: 3,
                                        maxWidth: 400,
                                        boxShadow: 3
                                    }}
                                >
                                    <Typography variant="h6" gutterBottom>
                                        {selectedLifeEvent}
                                    </Typography>
                                    <Typography variant="body2" color="text.secondary" paragraph>
                                        Begin your journey through {selectedLifeEvent.toLowerCase()}. 
                                        We'll guide you through all the services and support available.
                                    </Typography>
                                    <Button
                                        variant="contained"
                                        fullWidth
                                        startIcon={<span className="material-icons">play_arrow</span>}
                                        onClick={() => {
                                            // Start journey
                                            const newJourney = {
                                                name: selectedLifeEvent,
                                                startDate: new Date().toISOString(),
                                                progress: 0,
                                                completedTasks: 0,
                                                totalTasks: 10,
                                                color: '#' + Math.floor(Math.random()*16777215).toString(16)
                                            };
                                            setActiveJourneys([...activeJourneys, newJourney]);
                                            localStorage.setItem('activeJourneys', JSON.stringify([...activeJourneys, newJourney]));
                                            setJourneyMapOpen(false);
                                        }}
                                    >
                                        Begin Journey
                                    </Button>
                                </Paper>
                            )}
                        </DialogContent>
                    </Dialog>
                );
            }

            // Service Matcher Component
            function ServiceMatcher() {
                const [loading, setLoading] = useState(false);
                const [filters, setFilters] = useState({
                    matchType: 'all'
                });
                const [searchResults, setSearchResults] = useState([]);

                useEffect(() => {
                    if (serviceMatcherOpen) {
                        loadMatchedServices();
                    }
                }, [serviceMatcherOpen]);

                const loadMatchedServices = async () => {
                    setLoading(true);
                    
                    try {
                        // Build search query based on profile
                        const searchParams = new URLSearchParams({
                            q: '*',
                            per_page: '100',
                            include_html: 'false'
                        });

                        // Add filters based on profile attributes
                        if (profile.employment_status === 'unemployed') {
                            searchParams.append('q', 'jobseeker payment unemployment benefit');
                        }
                        if (profile.housing_status === 'renting') {
                            searchParams.append('q', 'rent assistance');
                        }
                        if (profile.age && profile.age < 30) {
                            searchParams.append('q', 'youth allowance young');
                        }
                        if (profile.has_children) {
                            searchParams.append('q', 'family tax benefit parenting payment');
                        }
                        if (profile.is_carer) {
                            searchParams.append('q', 'carer payment carer allowance');
                        }

                        // Fetch from Typesense
                        const response = await fetch(`${API_ENDPOINTS.search}?${searchParams}`);
                        if (!response.ok) throw new Error('Failed to search services');
                        
                        const data = await response.json();
                        
                        // Process results into service matches
                        const services = processSearchResults(data.results);
                        setMatchedServices(services);
                        
                    } catch (error) {
                        console.error('Error loading services:', error);
                        // Fallback to mock data if API fails
                        setMatchedServices(getMockServices());
                    } finally {
                        setLoading(false);
                    }
                };

                const processSearchResults = (results) => {
                    // Group by unique services and calculate match scores
                    const serviceMap = new Map();
                    
                    results.forEach(hit => {
                        const doc = hit.document;
                        const serviceKey = extractServiceName(doc.title, doc.content_text);
                        
                        if (!serviceMap.has(serviceKey)) {
                            serviceMap.set(serviceKey, {
                                id: doc.id,
                                name: serviceKey,
                                provider: doc.provider || 'Services Australia',
                                description: doc.content_text.substring(0, 150) + '...',
                                url: doc.url,
                                fragments: [doc],
                                matchScore: calculateMatchScore(doc),
                                eligibilityGaps: extractEligibilityGaps(doc)
                            });
                        } else {
                            // Add fragment to existing service
                            const service = serviceMap.get(serviceKey);
                            service.fragments.push(doc);
                            // Update match score if this fragment has a higher score
                            const newScore = calculateMatchScore(doc);
                            if (newScore > service.matchScore) {
                                service.matchScore = newScore;
                            }
                        }
                    });

                    // Convert to array and categorize
                    return Array.from(serviceMap.values())
                        .map(service => ({
                            ...service,
                            matchType: getMatchType(service.matchScore)
                        }))
                        .sort((a, b) => b.matchScore - a.matchScore);
                };

                const extractServiceName = (title, content) => {
                    // Extract service name from title or content
                    const servicePatterns = [
                        /^([\w\s]+(?:Payment|Pension|Allowance|Benefit|Card|Concession|Supplement))/i,
                        /\b(JobSeeker|Youth Allowance|Age Pension|Disability Support Pension|Carer Payment|Family Tax Benefit|Rent Assistance|Health Care Card)\b/i
                    ];
                    
                    for (const pattern of servicePatterns) {
                        const match = (title + ' ' + content).match(pattern);
                        if (match) return match[1].trim();
                    }
                    
                    // Fallback to title
                    return title.split(' - ')[0].split(' | ')[0].trim();
                };

                const calculateMatchScore = (doc) => {
                    let score = 50; // Base score
                    
                    // Check employment status match
                    if (profile.employment_status === 'unemployed' && 
                        (doc.content_text.toLowerCase().includes('unemployed') || 
                         doc.content_text.toLowerCase().includes('looking for work'))) {
                        score += 30;
                    }
                    
                    // Check age requirements
                    const ageMatch = doc.content_text.match(/aged?\s+(\d+)(?:\s+to\s+(\d+))?/i);
                    if (ageMatch && profile.age) {
                        const minAge = parseInt(ageMatch[1]);
                        const maxAge = ageMatch[2] ? parseInt(ageMatch[2]) : 100;
                        if (profile.age >= minAge && profile.age <= maxAge) {
                            score += 20;
                        } else {
                            score -= 30;
                        }
                    }
                    
                    // Check housing status
                    if (profile.housing_status === 'renting' && doc.content_text.toLowerCase().includes('rent')) {
                        score += 15;
                    }
                    
                    // Check for children
                    if (profile.has_children && doc.content_text.toLowerCase().includes('child')) {
                        score += 15;
                    }
                    
                    // Check for carer status
                    if (profile.is_carer && doc.content_text.toLowerCase().includes('carer')) {
                        score += 15;
                    }
                    
                    return Math.min(100, Math.max(0, score));
                };

                const extractEligibilityGaps = (doc) => {
                    const gaps = [];
                    const content = doc.content_text.toLowerCase();
                    
                    // Age gaps
                    const ageMatch = content.match(/aged?\s+(\d+)(?:\s+(?:or|and)\s+(?:over|above|older))?/i);
                    if (ageMatch && profile.age) {
                        const requiredAge = parseInt(ageMatch[1]);
                        if (profile.age < requiredAge) {
                            gaps.push(`Must be ${requiredAge} years or older`);
                        }
                    }
                    
                    // Employment gaps
                    if (content.includes('looking for work') && profile.employment_status !== 'unemployed') {
                        gaps.push('Must be actively looking for work');
                    }
                    
                    // Children gaps
                    if (content.includes('dependent child') && !profile.has_children) {
                        gaps.push('Must have dependent children');
                    }
                    
                    // Income test
                    if (content.includes('income test') || content.includes('means test')) {
                        gaps.push('Subject to income and assets test');
                    }
                    
                    // Residency
                    if (content.includes('australian resident')) {
                        gaps.push('Must be an Australian resident');
                    }
                    
                    return gaps;
                };

                const getMatchType = (score) => {
                    if (score >= 80) return 'full';
                    if (score >= 50) return 'partial';
                    return 'potential';
                };

                const getMockServices = () => {
                    // Fallback mock data
                    return [
                        {
                            id: 1,
                            name: 'JobSeeker Payment',
                            provider: 'Services Australia',
                            matchType: 'full',
                            matchScore: 95,
                            description: 'Financial support while you look for work',
                            eligibilityGaps: []
                        },
                        {
                            id: 2,
                            name: 'Rent Assistance',
                            provider: 'Services Australia',
                            matchType: 'full',
                            matchScore: 90,
                            description: 'Help with rent if you get certain payments',
                            eligibilityGaps: []
                        },
                        {
                            id: 3,
                            name: 'Youth Allowance',
                            provider: 'Services Australia',
                            matchType: profile.age && profile.age < 25 ? 'partial' : 'potential',
                            matchScore: profile.age && profile.age < 25 ? 75 : 30,
                            description: 'Support for young people who are studying or training',
                            eligibilityGaps: profile.age >= 25 ? ['Must be under 25 years old'] : ['Must be studying full-time']
                        }
                    ];
                };

                const getMatchTypeColor = (type) => {
                    switch(type) {
                        case 'full': return 'success';
                        case 'partial': return 'warning';
                        case 'potential': return 'default';
                        default: return 'default';
                    }
                };

                return (
                    <Dialog
                        open={serviceMatcherOpen}
                        onClose={() => setServiceMatcherOpen(false)}
                        maxWidth="md"
                        fullWidth
                    >
                        <DialogTitle>
                            <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
                                <Typography variant="h5">Services for You</Typography>
                                <IconButton onClick={() => setServiceMatcherOpen(false)}>
                                    <span className="material-icons">close</span>
                                </IconButton>
                            </Box>
                        </DialogTitle>
                        <DialogContent>
                            {/* Filter Tabs */}
                            <Tabs
                                value={filters.matchType}
                                onChange={(e, value) => setFilters({...filters, matchType: value})}
                                sx={{ mb: 3 }}
                            >
                                <Tab label="All Services" value="all" />
                                <Tab 
                                    label="Full Matches" 
                                    value="full" 
                                    icon={<Chip size="small" label={matchedServices.filter(s => s.matchType === 'full').length} />} 
                                    iconPosition="end" 
                                />
                                <Tab 
                                    label="Partial Matches" 
                                    value="partial" 
                                    icon={<Chip size="small" label={matchedServices.filter(s => s.matchType === 'partial').length} />} 
                                    iconPosition="end" 
                                />
                                <Tab 
                                    label="Potential Matches" 
                                    value="potential" 
                                    icon={<Chip size="small" label={matchedServices.filter(s => s.matchType === 'potential').length} />} 
                                    iconPosition="end" 
                                />
                            </Tabs>

                            {loading ? (
                                <Box sx={{ textAlign: 'center', py: 5 }}>
                                    <CircularProgress />
                                    <Typography sx={{ mt: 2 }}>Matching services to your profile...</Typography>
                                </Box>
                            ) : (
                                <Stack spacing={2}>
                                    {matchedServices
                                        .filter(service => filters.matchType === 'all' || service.matchType === filters.matchType)
                                        .map(service => (
                                            <Card key={service.id} className={`service-match-card ${service.matchType}-match`}>
                                                <CardContent>
                                                    <Box sx={{ display: 'flex', justifyContent: 'space-between', mb: 2 }}>
                                                        <Box>
                                                            <Typography variant="h6">{service.name}</Typography>
                                                            <Typography variant="body2" color="text.secondary">
                                                                {service.provider}
                                                            </Typography>
                                                        </Box>
                                                        <Box sx={{ textAlign: 'right' }}>
                                                            <Chip
                                                                label={`${service.matchScore}% Match`}
                                                                color={getMatchTypeColor(service.matchType)}
                                                                size="small"
                                                            />
                                                        </Box>
                                                    </Box>
                                                    
                                                    <Typography variant="body2" paragraph>
                                                        {service.description}
                                                    </Typography>

                                                    {service.eligibilityGaps && service.eligibilityGaps.length > 0 && (
                                                        <Box className="eligibility-gap">
                                                            <Typography variant="body2" fontWeight="bold" gutterBottom>
                                                                To qualify, you need:
                                                            </Typography>
                                                            <ul style={{ margin: 0, paddingLeft: 20 }}>
                                                                {service.eligibilityGaps.map((gap, i) => (
                                                                    <li key={i}><Typography variant="body2">{gap}</Typography></li>
                                                                ))}
                                                            </ul>
                                                        </Box>
                                                    )}

                                                    <Box sx={{ mt: 2, display: 'flex', gap: 1 }}>
                                                        <Button 
                                                            size="small" 
                                                            variant="contained"
                                                            href={service.url}
                                                            target="_blank"
                                                        >
                                                            Learn More
                                                        </Button>
                                                        <Button size="small" variant="outlined">
                                                            Check Eligibility
                                                        </Button>
                                                    </Box>
                                                </CardContent>
                                            </Card>
                                        ))}
                                </Stack>
                            )}
                        </DialogContent>
                    </Dialog>
                );
            }

            return (
                <>
                    <AppBar position="sticky" sx={{ bgcolor: '#66d3ee', color: '#333' }}>
                        <Toolbar>
                            <Box className="logo-container" sx={{ flexGrow: 1 }}>
                                <span className="material-icons" style={{ fontSize: 40, color: '#1976d2' }}>account_balance</span>
                                <Typography variant="h6" component="div">
                                    myGov Journey
                                </Typography>
                            </Box>
                            
                            <Button color="inherit" startIcon={<span className="material-icons">login</span>}>
                                Sign in
                            </Button>
                        </Toolbar>
                    </AppBar>

                    <Container maxWidth="lg" sx={{ mt: 4, mb: 4 }}>
                        <ProfileSheet />
                    </Container>

                    <JourneyMap />
                    <ServiceMatcher />

                    {/* Footer */}
                    <Box component="footer" sx={{ bgcolor: '#000', color: 'white', py: 6, mt: 8 }}>
                        <Container maxWidth="lg">
                            <Typography variant="body2" align="center">
                                We acknowledge the Traditional Custodians of the lands we live on.
                            </Typography>
                        </Container>
                    </Box>
                </>
            );
        }

        // Render the app
        ReactDOM.render(<App />, document.getElementById('root'));
    </script>
</body>
</html>
