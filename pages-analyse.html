<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Pages Analyse (Browser)</title>
  <style>
    body { font-family: system-ui, Arial, sans-serif; margin: 0; padding: 16px; background: #0b0f14; color: #e6edf3; }
    header { display: grid; grid-template-columns: repeat(4, 1fr); gap: 8px; margin-bottom: 12px; }
    input, select, button { padding: 8px; background: #0f1720; color: #e6edf3; border: 1px solid #233041; border-radius: 6px; }
    button { cursor: pointer; }
    .row { display: grid; grid-template-columns: repeat(4, 1fr); gap: 8px; margin-bottom: 12px; }
    #results { margin-top: 12px; }
    table { width: 100%; border-collapse: collapse; }
    th, td { border-bottom: 1px solid #1f2937; padding: 6px; font-size: 13px; }
    a { color: #60a5fa; text-decoration: none; }
  </style>
</head>
<body>
  <h2>Pages Analyse (Browser → Typesense direct)</h2>
  <div class="row">
    <input id="ts_base" placeholder="Typesense base (http://localhost:8108)" value="http://localhost:8108" />
    <input id="ts_key" placeholder="Typesense API key" />
    <input id="site_a" placeholder="Site A (e.g., servicesaustralia.gov.au)" value="servicesaustralia.gov.au" />
    <input id="site_b" placeholder="Site B (e.g., my.gov.au)" value="my.gov.au" />
  </div>
  <div class="row">
    <select id="metric">
      <option value="combined">metric: combined</option>
      <option value="tags">metric: tags</option>
      <option value="embedding">metric: embedding</option>
      <option value="link">metric: link</option>
    </select>
    <input id="threshold" type="number" step="0.01" min="0" max="1" value="0.4" />
    <input id="max_pairs" type="number" step="100" min="100" value="50000" />
    <div style="display:flex;gap:8px">
      <button id="run">Run similarity</button>
      <button id="export_csv">Download CSV</button>
      <button id="export_graph">Download link graph JSON</button>
      <button id="build_pages">Build content_pages in Typesense</button>
    </div>
  </div>
  <div id="status"></div>
  <div id="results"></div>

  <script>
    function tsBase() { return (document.getElementById('ts_base').value || 'http://localhost:8108').trim(); }
    function tsKey() { return (document.getElementById('ts_key').value || '').trim(); }
    async function tsSearch(collection, params) {
      const res = await fetch(`${tsBase()}/collections/${encodeURIComponent(collection)}/documents/search`, {
        method: 'POST', headers: { 'Content-Type': 'application/json', 'X-TYPESENSE-API-KEY': tsKey() }, body: JSON.stringify(params)
      });
      if (!res.ok) {
        const err = new Error(`${collection} HTTP ${res.status}`);
        err.status = res.status;
        throw err;
      }
      return await res.json();
    }
    async function tsFetchAll(collection, fields, limit=50000) {
      const per_page = 250; let page = 1; const out = [];
      while (out.length < limit) {
        let data;
        try {
          data = await tsSearch(collection, { q:'*', query_by:'title', include_fields: fields.join(','), per_page, page });
        } catch (e) {
          if ((e && (e.status === 404 || String(e.message||'').includes('HTTP 404')))) {
            // Collection not found; return whatever we have (likely empty) so caller can fallback
            return out;
          }
          throw e;
        }
        const hits = data.hits || []; if (!hits.length) break;
        hits.forEach(h => out.push(h.document));
        if (data.found <= page * per_page) break; page++;
      }
      return out.slice(0, limit);
    }
    function baseUrl(u){ try{ const x=new URL(u); x.hash=''; x.search=''; return x.toString(); } catch{ return (u||'').split('#')[0]; } }
    function hostOf(u){ try{ return new URL(u).hostname; } catch{ return ''; } }
    function tokens(s){ return (s||'').toLowerCase().replace(/[^a-z0-9\s]/g,' ').split(/\s+/).filter(Boolean); }
    function buildHashedEmbedding(text, dim=256){ const v=new Array(dim).fill(0); for(const t of tokens(text)){ let h=2166136261; for(let i=0;i<t.length;i++){ h^=t.charCodeAt(i); h=(h*16777619)>>>0; } v[h%dim]++; } const n=Math.sqrt(v.reduce((s,x)=>s+x*x,0))||1; return v.map(x=>x/n); }
    function jaccard(a,b){ if(!a.size && !b.size) return 1; let inter=0; for(const x of a) if(b.has(x)) inter++; const u=a.size+b.size-inter; return u? inter/u : 0; }
    function cosine(a,b){ if(!Array.isArray(a)||!Array.isArray(b)||a.length!==b.length||!a.length) return 0; let dot=0,na=0,nb=0; for(let i=0;i<a.length;i++){ const x=a[i]||0,y=b[i]||0; dot+=x*y; na+=x*x; nb+=y*y; } return (!na||!nb)?0:dot/Math.sqrt(na*nb); }
    function aggregatePagesFromFragments(frags){ const pages=new Map(); for(const f of frags){ const p=baseUrl(f.url||''); if(!p) continue; if(!pages.has(p)) pages.set(p,{url:p,host:hostOf(p),title:undefined,fragment_ids:[],fragment_count:0,life_events:new Set(),categories:new Set(),states:new Set(),keywords:new Set(),content_text:'',out_links:new Set(),out_link_tokens:new Set(),_lvl0Counts:new Map()}); const a=pages.get(p); a.fragment_ids.push(f.id); a.fragment_count++; (f.life_events||[]).forEach(x=>a.life_events.add(x)); (f.categories||[]).forEach(x=>a.categories.add(x)); (f.states||[]).forEach(x=>a.states.add(x)); if(a.content_text.length<40000) a.content_text+=(a.content_text?'\n':'')+(f.content_text||'').slice(0,4000); (f.search_keywords||[]).forEach(k=>a.keywords.add(k)); const html=f.content_html||''; const hrefs=Array.from(html.matchAll(/href\s*=\s*"([^"]+)"/gi)).map(m=>m[1]); for(const h of hrefs){ try{ const u=new URL(h,p); if(!['http:','https:'].includes(u.protocol)) continue; const b=baseUrl(u.toString()); a.out_links.add(b); const seg=(u.pathname||'/').split('/').filter(Boolean)[0]||''; const host=(u.hostname||'').toLowerCase(); if(host) a.out_link_tokens.add(host); if(host&&seg) a.out_link_tokens.add(`${host}/${seg.toLowerCase()}`);}catch{}} } const docs=[]; for(const a of pages.values()){ if(a._lvl0Counts.size) a.title=Array.from(a._lvl0Counts.entries()).sort((x,y)=>y[1]-x[1])[0][0]; docs.push({url:a.url,host:a.host,title:a.title,fragment_count:a.fragment_count,life_events:Array.from(a.life_events),categories:Array.from(a.categories),states:Array.from(a.states),keywords:Array.from(a.keywords),embedding:buildHashedEmbedding(a.content_text||'',256),out_links:Array.from(a.out_links),out_link_tokens:Array.from(a.out_link_tokens)}); } return docs; }
    function computePairs(A,B,metric,threshold,maxPairs){ const idxTag=new Map(),idxKey=new Map(),idxLink=new Map(); const nrm=s=>String(s||'').toLowerCase(); for(let i=0;i<B.length;i++){ const d=B[i]; const tags=new Set([...(d.life_events||[]),...(d.categories||[])]); for(const t of tags){ const k=nrm(t); if(!idxTag.has(k)) idxTag.set(k,new Set()); idxTag.get(k).add(i);} for(const k of (d.keywords||[])){ const kk=nrm(k); if(!idxKey.has(kk)) idxKey.set(kk,new Set()); idxKey.get(kk).add(i);} for(const t of (d.out_link_tokens||[])){ const kk=nrm(t); if(!idxLink.has(kk)) idxLink.set(kk,new Set()); idxLink.get(kk).add(i);} } const pairs=[]; const seen=new Set(); for(const a of A){ const cand=new Set(); const aTags=new Set([...(a.life_events||[]),...(a.categories||[])]); for(const t of aTags){ const s=idxTag.get(nrm(t)); if(s) s.forEach(i=>cand.add(i)); } let c1=0; for(const k of (a.keywords||[])){ if(c1>=25) break; const s=idxKey.get(nrm(k)); if(s){ s.forEach(i=>cand.add(i)); c1++; } } let c2=0; const aLinks=new Set(a.out_link_tokens||[]); for(const t of aLinks){ if(c2>=25) break; const s=idxLink.get(nrm(t)); if(s){ s.forEach(i=>cand.add(i)); c2++; } } for(const i of cand){ const b=B[i]; const key=a.url+'|'+b.url; if(seen.has(key)) continue; seen.add(key); const bTags=new Set([...(b.life_events||[]),...(b.categories||[])]); const tagSim=jaccard(aTags,bTags); const embSim=(Array.isArray(a.embedding)&&Array.isArray(b.embedding))?cosine(a.embedding,b.embedding):0; const linkSim=jaccard(aLinks,new Set(b.out_link_tokens||[])); let score; if(metric==='tags') score=tagSim; else if(metric==='embedding') score=embSim; else if(metric==='link') score=linkSim; else score=0.5*tagSim+0.3*embSim+0.2*linkSim; if(score>=threshold) pairs.push({a,b,score,tagSim,embSim,linkSim}); } } pairs.sort((x,y)=>y.score-x.score); return pairs.slice(0,maxPairs); }
    function toCSV(rows){ if(!rows.length) return ''; const headers=Object.keys(rows[0]); const esc=v=>'"'+String(v==null?'':v).replace(/"/g,'""')+'"'; const out=[headers.map(esc).join(',')]; for(const r of rows){ out.push(headers.map(h=>esc(r[h])).join(',')); } return out.join('\n'); }

    let lastPairs = [];

    async function runSimilarity() {
      const siteA = document.getElementById('site_a').value.trim();
      const siteB = document.getElementById('site_b').value.trim();
      const metric = document.getElementById('metric').value;
      const threshold = parseFloat(document.getElementById('threshold').value || '0.4');
      const maxPairs = parseInt(document.getElementById('max_pairs').value || '50000', 10);
      const status = document.getElementById('status');
      status.textContent = 'Loading…';
      try {
        let pages = await tsFetchAll('content_pages', ['url','host','title','life_events','categories','states','keywords','embedding','out_links','out_link_tokens','fragment_count'], 100000);
        if (!pages || pages.length === 0) {
          status.textContent = 'content_pages missing or empty, falling back to content_fragments…';
          const frags = await tsFetchAll('content_fragments', ['id','url','title','content_text','content_html','life_events','categories','states','hierarchy_lvl0','search_keywords'], 200000);
          if (!frags || frags.length === 0) throw new Error('No content_pages or content_fragments available in Typesense');
          pages = aggregatePagesFromFragments(frags);
        }
        const A = pages.filter(d => (hostOf(d.url)||'').endsWith(siteA));
        const B = pages.filter(d => (hostOf(d.url)||'').endsWith(siteB));
        lastPairs = computePairs(A, B, metric, threshold, maxPairs);
        renderTable(lastPairs.slice(0, 200));
        status.textContent = `Pairs: ${lastPairs.length} (showing top 200)`;
      } catch (e) {
        status.textContent = 'Error: ' + e.message;
      }
    }

    function renderTable(pairs) {
      const el = document.getElementById('results');
      if (!pairs.length) { el.innerHTML = '<em>No results</em>'; return; }
      const rows = pairs.map(p => `
        <tr>
          <td><a href="${p.a.url}" target="_blank">${p.a.title || p.a.url}</a></td>
          <td><a href="${p.b.url}" target="_blank">${p.b.title || p.b.url}</a></td>
          <td>${p.score.toFixed(3)}</td>
          <td>${p.tagSim.toFixed(3)}</td>
          <td>${p.embSim.toFixed(3)}</td>
          <td>${p.linkSim.toFixed(3)}</td>
        </tr>`).join('');
      el.innerHTML = `
        <table>
          <thead><tr><th>Page A</th><th>Page B</th><th>Score</th><th>Tags</th><th>Embed</th><th>Link</th></tr></thead>
          <tbody>${rows}</tbody>
        </table>`;
    }

    function download(name, text) {
      const a = document.createElement('a');
      a.href = URL.createObjectURL(new Blob([text], { type: 'text/plain' }));
      a.download = name; a.click();
    }

    async function ensurePagesCollection() {
      const base = tsBase(); const key = tsKey();
      // check if exists
      let exists = true;
      try {
        const res = await fetch(`${base}/collections/content_pages`, { headers: { 'X-TYPESENSE-API-KEY': key } });
        if (!res.ok) exists = false;
      } catch { exists = false; }
      if (exists) return true;
      // create
      const schema = {
        name: 'content_pages', enable_nested_fields: true,
        fields: [
          { name: 'crawl_version', type: 'int32' },
          { name: 'last_seen_at', type: 'int64' },
          { name: 'url', type: 'string', facet: true },
          { name: 'host', type: 'string', facet: true },
          { name: 'title', type: 'string', optional: true },
          { name: 'content_text', type: 'string', optional: true },
          { name: 'life_events', type: 'string[]', facet: true },
          { name: 'categories', type: 'string[]', facet: true },
          { name: 'states', type: 'string[]', facet: true },
          { name: 'provider', type: 'string[]', facet: true, optional: true },
          { name: 'governance', type: 'string[]', facet: true, optional: true },
          { name: 'stage', type: 'string[]', facet: true, optional: true },
          { name: 'stage_variant', type: 'string[]', facet: true, optional: true },
          { name: 'fragment_ids', type: 'string[]' },
          { name: 'fragment_count', type: 'int32' },
          { name: 'keywords', type: 'string[]', optional: true },
          { name: 'embedding', type: 'float[]', num_dim: 256, optional: true },
          { name: 'out_links', type: 'string[]', optional: true },
          { name: 'out_link_tokens', type: 'string[]', optional: true }
        ]
      };
      const res = await fetch(`${base}/collections`, {
        method: 'POST', headers: { 'Content-Type': 'application/json', 'X-TYPESENSE-API-KEY': key }, body: JSON.stringify(schema)
      });
      if (!res.ok) { const t = await res.text(); throw new Error(`Create content_pages failed: ${res.status} ${t}`); }
      return true;
    }

    function nowSec(){ return Math.floor(Date.now()/1000); }
    function jsonl(rows){ return rows.map(r => JSON.stringify(r)).join('\n'); }

    async function buildPagesInTypesense() {
      const status = document.getElementById('status');
      status.textContent = 'Building content_pages: fetching fragments…';
      const flds = ['id','url','title','content_text','content_html','life_events','categories','states','provider','governance','stage','stage_variant','hierarchy_lvl0','search_keywords'];
      const frags = await tsFetchAll('content_fragments', flds, 200000);
      if (!frags || frags.length === 0) { status.textContent = 'No fragments found in Typesense'; return; }
      status.textContent = `Aggregating ${frags.length} fragments…`;
      const pages = aggregatePagesFromFragments(frags);
      status.textContent = `Preparing to write ${pages.length} pages…`;
      await ensurePagesCollection();
      // import in batches via JSONL upsert
      const base = tsBase(); const key = tsKey();
      const CV = nowSec(); const LS = Date.now();
      // enrich with crawl_version/last_seen
      for (const p of pages) { p.crawl_version = CV; p.last_seen_at = LS; }
      for (let i=0; i<pages.length; i+=500) {
        const batch = pages.slice(i, i+500);
        status.textContent = `Writing pages ${i+1}-${Math.min(i+batch.length, pages.length)} of ${pages.length}…`;
        const res = await fetch(`${base}/collections/content_pages/documents/import?action=upsert`, {
          method: 'POST', headers: { 'Content-Type': 'text/plain', 'X-TYPESENSE-API-KEY': key }, body: jsonl(batch)
        });
        if (!res.ok) { const t = await res.text(); throw new Error(`Import failed: ${res.status} ${t}`); }
      }
      status.textContent = `Done. Indexed ${pages.length} pages into content_pages.`;
    }

    async function exportCSV() {
      if (!lastPairs.length) return alert('Run similarity first');
      const rows = lastPairs.map(p => ({
        a_url: p.a.url, b_url: p.b.url,
        a_title: p.a.title||'', b_title: p.b.title||'',
        score: p.score.toFixed(3), tag_sim: p.tagSim.toFixed(3), emb_sim: p.embSim.toFixed(3), link_sim: p.linkSim.toFixed(3)
      }));
      download('pages_similarity.csv', toCSV(rows));
    }

    async function exportGraph() {
      let pages = await tsFetchAll('content_pages', ['url','host','title','out_links'], 100000);
      if (!pages || pages.length === 0) {
        const frags = await tsFetchAll('content_fragments', ['id','url','title','content_text','content_html','life_events','categories','states','hierarchy_lvl0','search_keywords'], 200000);
        if (!frags || frags.length === 0) return alert('No content_pages or content_fragments available');
        pages = aggregatePagesFromFragments(frags);
      }
      const siteA = document.getElementById('site_a').value.trim();
      const siteB = document.getElementById('site_b').value.trim();
      const inScope = (d)=>{ const h=(hostOf(d.url)||''); return h.endsWith(siteA) || h.endsWith(siteB); };
      const nodes = pages.filter(inScope);
      const nodeByUrl = new Map(nodes.map(n=>[n.url,n]));
      const edges = [];
      for (const p of nodes) {
        const links = Array.from(new Set(p.out_links||[])).slice(0, 1000);
        for (const L of links) { if (nodeByUrl.has(L)) edges.push({ source: p.url, target: L }); if (edges.length>=50000) break; }
        if (edges.length>=50000) break;
      }
      const graph = { nodes: nodes.map(n=>({ id:n.url, url:n.url, title:n.title||n.url, host:n.host||hostOf(n.url) })), edges };
      download('link_graph.json', JSON.stringify(graph));
    }

    document.getElementById('run').addEventListener('click', runSimilarity);
    document.getElementById('export_csv').addEventListener('click', exportCSV);
    document.getElementById('export_graph').addEventListener('click', exportGraph);
    document.getElementById('build_pages').addEventListener('click', async () => {
      try { await buildPagesInTypesense(); } catch (e) { document.getElementById('status').textContent = 'Error: ' + e.message; }
    });
  </script>
</body>
</html>
